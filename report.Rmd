---
title: "Isokinetic strength data processing report"
author: "Lucas Veras"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    number_sections: true
    highlight: tango
    code_folding: "show"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r prepare, include=FALSE}
library(tidyverse)
source("R/functions/read_strength_data.R")
source("R/functions/plot_divisions.R")
source("R/functions/separate_file.R")
source("R/functions/quality_control.R")
source("R/functions/count_reps.R")
source("R/functions/detect_ROM.R")
source("R/functions/correct_ROM.R")
source("R/functions/compute_variables.R")
```

# Introduction 

The present report shows the processing of isokinetic strength raw data test from the BaSEIB Clinical Trial. The tests were performed using an isokinetic dynamometer (Biodex System 4 Pro), with a maximum dynamic concentric muscle strength test for knee and trunk muscles. The protocols were:

**A) Knee muscle strength test**

The range of motion was 90º. Two isokinetic speeds were used:

  - 4 repetitions at 60º/s
  - 8 repetitions at 180º/s
  
**B) Trunk muscle strength test**

The range of motion was 60º. Two isokinetic speeds were used:

  - 4 repetitions at 60º/s
  - 6 repetitions at 120º/s
  
There was a 2 minutes rest period between the 2 velocities tests.

The manufacturer-supplied software (Biodex Advantage Software, V.4X) was used to download the raw data. Knee muscle strength test was also corrected for gravity by the software.

Throughout the rest of this document, the examples of code and plots used will be referred to the knee muscle strength tests. The Github repository with the code for these analysis can be found [here](https://github.com/verasls/BaSEIB_isokinetic_strength).

# Separate repetitions

First of all, we needed to accurately determine the start and end points of each of the test "half" repetitions. A “half” repetition in the away direction (e.g. knee extension) and a “half” repetition in the towards direction (e.g. knee flexion) constitutes a whole repetition. As stated by the Biodex Advantage Sotware (V.4X) Operation Manual, the dinamometer velocity signal is the most reliable source for determination of half repetitions, as they contain information about both the velocity magnitude and direction. Therefore, the function `find_divisions()` was defined to scan the velocity signal and mark all points of zero crossings, in other words, where the velocity signal changes sign. These points would be further processed to ensure that they correspond to the exact limits of the half repetition, and not generated by signal noise.

The figure below shows a raw torque X time plot for the isokinetic testing of knee muscle strength at 60º/s.

```{r strength_plot, fig.height=4, fig.width=9, dev='svg'}

D <- read_strength_data(
  "data/raw/knee/60gs/1st_eval/1st_strength_knee_raw_60g_003.txt"
  )

ggplot(data = D) +
    geom_line(mapping = aes(x = time, y = torque), colour = "blue") +
    labs(
      x = "Time (ms)",
      y = expression(Torque~(N*"\U00B7"*m)),
      title = "1st eval ID 003 - knee 60º/s"
    ) + 
    theme(plot.title = element_text(hjust = 0.5))
```

The figure below shows the same plot as above, but with the vertical black lines representing all the 32 identified zero crossing points, without removing noise.

```{r raw_divisions_plot, fig.height=4, fig.width=9, dev='svg'}
file <- "data/raw/knee/60gs/1st_eval/1st_strength_knee_raw_60g_003.txt"
M <- as.matrix(read_strength_data(file))

# Ensure 1st velocity value to be positive
if (M[1, 5] <= 0) {
  # Find first positive velocity value
  p <- min(which(M[, 5] > 0))
  M <- M[p:nrow(M), ]
}

# Find zero crossings in velocity signal
idx <- vector() # Division points indices
j   <- 1        # Index counter
for (i in 2:nrow(M)) {
  # If product < 0, it means different signs
  if (M[i - 1, 5] * M[i, 5] < 0) {
    idx[j] <- i
    j <- j + 1
  } else {
    # If product is 0, at least one of the velocity values is 0
    # Mark where velocity is 0 as index
    if (M[i - 1, 5] * M[i, 5] == 0) {
      if (min(which(M[(i - 1):i, 5] == 0)) == 1) {
        idx[j] <- i - 1
        j <- j + 1
      } else {
        if (min(which(M[(i - 1):i, 5] == 0)) == 2) {
          idx[j] <- i
          j <- j + 1
        }
      }
    }
  }
  idx <- unique(idx[!is.na(idx)])
}

# Find time points of velocity zero crossings
t <- vector()
for (i in 1:length(idx)) {
  t[i] <- M[idx[i], 1]
}

ggplot(data = as_tibble(M)) +
  geom_line(mapping = aes(x = time, y = torque), colour = "blue") +
  geom_vline(xintercept = t) +
  labs(
    x = "Time (ms)",
    y = expression(Torque~(N*"\U00B7"*m)),
    title = "1st eval ID 003 - knee 60º/s"
  ) + 
  theme(plot.title = element_text(hjust = 0.5))
```

The next figure shows the divisions without the noise, as determined by the `find_divisions()` function. It removed 24 false disivions points, keeping only the 8 points that correctly identify the half repetitions.

```{r divisions_plot, fig.height=4, fig.width=9, dev='svg'}
plot_divisions(
  file = "data/raw/knee/60gs/1st_eval/1st_strength_knee_raw_60g_003.txt", 
  save = FALSE
  )
```

All the torque X time plots with the half repetition divisions were saved into separate files to manually inspect for any possible errors.

# Quality control

The next step was the application of the `quality_control()` function, to further ensure that there are no errors in the process of spliting the test data into the half repetitions. This function takes into account the "type" of half repetition, either extension or flexion, and checks whether there are any errors in the torque and velocity signals sign, and also in the anatomic position angle, using the following criteria:

**Knee extension**

- Torque and velocity signals should be positive values
- Anatomic position angles should decrease during the half repetition

**Knee flexion**

- Torque and velocity signals should be negative values
- Anatomic position angles should increase during the half repetition

The `quality_control()` function have also an argument that allows the user to specify the range of motion (ROM; start and end points in degrees) at which the function will inspect the file. At these analysis the ROM is set from 10º to 80º `(10:80)`. The function, then, returns information when the subject`s ROM does not match the selected range.

The quality control process continues with the utilization of the `count_reps()` function, which, as the name states, counts the number of repetitions in a given test, and then returns which subjects present a number of repetitions different than the expected for the test.

The final step is to correct the anatomic position values of some subjects that were shown to present errors in the ROM. In all of the cases analyzed, even though the subjects presented anatomic position values different than expected for the test, the equipment postition presented the correct ROM. Therefore, the wrong anatomic position is due to an error in the equipment configuration before the test. In this cases, the `correct_ROM()` function was used to reset the anatomic position to their actual value.

# Compute variables

After the raw data was correctly processed, a few variables were computed. The description of these variables, as well as the code used to compute them, is shown below.

**Variables**

- **Peak torque:** highest muscular force output at any moment during a half repetition
- **Peak torque / body mass:** the peak torque value normalized by the total body mass
- **Peak torque / limb mass:** the peak torque value normalized by the lower limb lean mass
- **Peak torque angle:** the point in the ROM where the peak torque is produced
- **Total work:** total muscular force output during a half repetition
- **Average power:** the average rate at which work is done
- **Peak power:** the maximum rate at which work is done

```{r prepare_variables, include=FALSE}
source("R/functions/select_ROM.R")
source("R/functions/work_integration.R")
source("R/functions/compute_power.R")

file <- "data/processed/knee/60gs/1st_eval/separate_reps/1st_strength_knee_60g_001_ext_1.txt"

D <- select_ROM(file, 10:80)
B <- read.csv("data/raw/body_composition.csv")
  
  # Detect parameters
    # For ID and rep, the chunk of the string to be subset depends on the length
    # of the string
  if (str_detect(file, "180gs")) {
    if (str_length(file) == 86) {
      ID  <- str_sub(file, str_length(file) - 13, str_length(file) - 11)  
      rep <- str_sub(file, str_length(file) - 9, str_length(file) - 4)
    } else {
      ID  <- str_sub(file, str_length(file) - 12, str_length(file) - 10) 
      rep <- str_sub(file, str_length(file) - 8, str_length(file) - 4)
    }
  } else {
    ID  <- str_sub(file, str_length(file) - 12, str_length(file) - 10)
    rep <- str_sub(file, str_length(file) - 8, str_length(file) - 4)
    
  }
  BM  <- B[which(B[, 1] == as.numeric(ID)), 2] # body mass
  LM  <- B[which(B[, 1] == as.numeric(ID)), 4] # lower limb mass
  
```

```{r compute_variables}
# Code used to compute the variables, where:
#   - D is a data frame containing the half repetition data;
#   - D[, 2] specifies the colunm with the torque values;
#   - BM represents the body mass;
#   - LM represents the lower limb lean mass.

peak_torque       <- max(abs(D[, 2]))
peak_torque_BM    <- peak_torque / BM
peak_torque_LM    <- peak_torque / LM
peak_torque_angle <- min(unname(D[which(abs(D[, 2]) == peak_torque), 4]))
total_work        <- work_integration(D)
average_power     <- compute_power(D)[2]
peak_power        <- compute_power(D)[1]
```

For the computation of some variables, new functions have been defined. As the muscle force output varies throughout the test, the total work done during one half repetition must be computed as a numerical integration, where the work (W) performed from the start point (a) to the end point (b), by a force (f(x)), is obtained as follows:

W = $\int_{a}^{b} f(x) \; dx$

The code implementation of this integral is done by the function `work_integration()` and is shown below:

```{r work_integration}
work_integration <- function(df) {
  # Computes total work (in Nm) from a isokinetic strength test data
  #
  # Args:
  #   df: a data frame containing isokinetic strength test data
  #
  # Returns:
  #   The absolute value of total work done
  
  M <- as.matrix(df)
  n <- dim(M)[1] - 1 # Gets the number of intervals in the matrix
  
  # Numerical integration
  # M[, 2]: torque column
  # M[, 3]: position column
  sum <- 0.0
  for (i in 1:n) {				
    sum <- sum - M[i, 2] * M[i, 3] - M[i + 1, 2] * M[i, 3] + M[i, 2] * M[i + 1, 3] + M[i + 1, 2] * M[i + 1, 3]
  }
  sum <- pi * sum / 360.0 # Correcting value

  return(unname(abs(sum)))
}
```

The `compute_power()` function (code below) computes both average and peak power. The power value is obtained by the multiplication of torque and velocity.

```{r compute_power}
compute_power <- function(df) {
  # Compute peak and average power (in Watt)
  #
  # Args:
  #   df: a data frame containing isokinetic strength test data
  #
  # Returns:
  #   A vector containing the peak and average power values, respectively
  
  M <- as.matrix(df)
  n <- dim(M)[1] - 1 
  
  # Maximum value gets initialized with first power value
  # M[, 2]: torque column
  # M[, 5]: velocity column
  max <- abs(M[1, 2] * M[1, 5]) 
  # Avarage starts as a summation of all values
  avg <- max
  # For each of the n integration intervals minus the first, which was already computed	  
  for (i in 2:n) {	
  	value <- abs(M[i, 2] * M[i, 5])		
  	avg   <- avg + value
  	if (value > max) {
  		max <- value
  	}
  }
  
  # Averaging and changing from degrees to radians
  avg <- pi * (avg / n) / 180 
  # Changing from degrees to radians
  max <- pi * max / 180
  
  # Returning max and avarega
  vec <- c(max, avg)
  
  return(unname(vec))	
}
```

# Selected range of motion

For the whole quality control and variables computation processes, an option to select a ROM within the half repetition data was activated. For the knee muscle strength test the selected ROM was from 10º to 80º, excluding the first and last 10º. This was done to ensure that the non-isokinetic portions of the test (acceleration and deceleration) are excluded from the analyses.

# Final data frame

After these variables were computed for all subjects, a data frame was built. A fragment of a final data frame is shown below as example.

```{r compute_all, results="hide"}
data_60gs_1st <- compute_variables(
  "data/processed/knee/60gs/1st_eval/separate_reps",
  1:91, 10:80
)
```

```{r db_example}
knitr::kable(data_60gs_1st[1:8, ])
```

# R session info

```{r session_info}
devtools::session_info()
```

